/*
 * Simple Stupid Synthesizer
 *
 * Copyright (C) 2023 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include "simple-stupid-synth.hpp"
#include "i2s-audio-target.hpp"
#include "pwm-audio-target.hpp"
#include <network-source.hpp>
#include <math.h>
#include "pico/stdlib.h"
#include <wifi-stuff.hpp>
#include <cstdio>
#include "ntp.hpp"
#include "display.h"
#include "led.h"

//#define USE_PWM_AUDIO

const uint32_t
Simple_stupid_synth::GPIO_PIN_LED = 4; // 25 is used for WiFi on pico_w

const uint32_t MAGNETIC_NORTH = 6;
const uint32_t MAGNETIC_SOUTH = 7;

const uint32_t
Simple_stupid_synth::DEFAULT_SAMPLE_FREQ = 24000; // [HZ]

const uint8_t
Simple_stupid_synth::VOL_BITS = 8;

Simple_stupid_synth::
Simple_stupid_synth(Audio_target *const audio_target,
                    MIDI_state_machine *const midi_state_machine,
                    Network_source *const network_source,
                    NTP_client *const ntp,
                    const uint8_t gpio_pin_activity_indicator) :
  _is_stereo(audio_target->is_stereo()),
  _audio_target(audio_target), _midi_state_machine(midi_state_machine),
  _network_source(network_source),
  _ntp(ntp)
{
  const uint32_t sample_freq = _audio_target->get_sample_freq();
  _midi_state_machine->init(sample_freq, gpio_pin_activity_indicator);
  sleep_ms(10);
}

void
Simple_stupid_synth::synth_task()
{
  struct audio_buffer *audio_buffer = _audio_target->take_audio_buffer(false);
  if (!audio_buffer) {
    return;
  }
  const uint32_t audio_buffer_sample_count = audio_buffer->max_sample_count;
  if (!audio_buffer_sample_count) {
    return;
  }
  audio_buffer->sample_count = audio_buffer_sample_count;
  int16_t *out = (int16_t *) audio_buffer->buffer->bytes;
  const uint16_t vol_mul = round(2.0 * (((long)1u) << VOL_BITS));
  const size_t num_osc = MIDI_state_machine::NUM_OSC;
  const uint32_t count_inc = MIDI_state_machine::COUNT_INC;
  MIDI_state_machine::osc_status_t *osc_statuses =
    _midi_state_machine->get_osc_statuses();
  const uint32_t total_sample_count =
    audio_buffer->max_sample_count * (_is_stereo ? 2 : 1);
  for (uint32_t sample_index = 0; sample_index < total_sample_count;) {
    int64_t sample_value = 0;
    for (size_t osc = 0; osc < num_osc; osc++) {
      MIDI_state_machine::osc_status_t *osc_status = &osc_statuses[osc];
      uint32_t elongation = osc_status->elongation;
      if (elongation) {
        const uint32_t count_wrap = osc_status->count_wrap;
        uint32_t count = osc_status->count;
        count += count_inc;
        if (count >= count_wrap) {
          count -= count_wrap;
          elongation = -elongation;
          osc_status->elongation = elongation;
        }
        osc_status->count = count;
        sample_value += elongation;
      }
    }
    const int16_t scaled_sample_value =
      (int16_t)((sample_value * vol_mul) >> VOL_BITS);
    if (_is_stereo) {
      out[sample_index++] = scaled_sample_value; // left channel
      out[sample_index++] = scaled_sample_value; // right channel
    } else {
      out[sample_index++] = scaled_sample_value; // mono channel
    }
  }
  _audio_target->give_audio_buffer(audio_buffer);
}

#include "hardware/adc.h"

void init_adc(void)
{
  adc_init();
  adc_gpio_init(26);
  adc_select_input(0);
}

#define ADC_THRESHOLD 0x20

void adc_task(void)
{
  const float conversion_factor = 3.3f / (1 << 12);
  static uint16_t last_result = 0;
  uint16_t result = adc_read();

  if ((result < last_result - ADC_THRESHOLD) ||
      (result > last_result + ADC_THRESHOLD))
  {
    printf("pot: 0x%03x, voltage: %f V\n", result, result * conversion_factor);
    last_result = result;

    uint8_t r, g, b;
    hue2rgb(result>>4, &r, &g, &b);
    set_first_led(r, g, b);
    update_leds();
  }
}

void init_magnetic_sensor(void)
{
  gpio_init(MAGNETIC_NORTH);
  gpio_init(MAGNETIC_SOUTH);
  gpio_pull_down(MAGNETIC_NORTH);
  gpio_pull_down(MAGNETIC_SOUTH);
  gpio_set_dir(MAGNETIC_NORTH, GPIO_IN);
  gpio_set_dir(MAGNETIC_SOUTH, GPIO_IN);
}

void magnetic_task(void)
{
  if (!gpio_get(MAGNETIC_NORTH))
  {
    set_first_led(0xff, 0x00, 0x00);
    update_leds();
  }
  if (!gpio_get(MAGNETIC_SOUTH))
  {
    set_first_led(0x00, 0xff, 0x00);
    update_leds();
  }
}

void
Simple_stupid_synth::main_loop()
{
  for (;;) {
    _midi_state_machine->tx_task();
    _midi_state_machine->rx_task();
    _network_source->rx_task();
    _ntp->update_time();
    synth_task();
    adc_task();
    magnetic_task();
  }
}

void display_wifi()
{
  memset(display_buffer, 0, SSD1306_BUF_LEN);
  write_string(2, 0, "waiting for WiFi");
  write_string(2, 8, "SSID " WIFI_SSID);
  write_string(38, is_large_display()?56:24, "[" NICK "]");
  render(&full_frame_area);
}

void display_waiting()
{
  memset(display_buffer, 0, SSD1306_BUF_LEN);
  write_string(2, 16, "waiting for notes");
  write_string(38, is_large_display()?56:24, "[" NICK "]");
  render(&full_frame_area);
}

int main()
{
  stdio_init_all();

  printf("\n\nmain()\n");

#ifdef USE_PWM_AUDIO
  const uint8_t gpio_pin_pwm_mono = PICO_AUDIO_PWM_L_PIN; // GPIO 0 (PWM_L)
  PWM_audio_target audio_target(Simple_stupid_synth::DEFAULT_SAMPLE_FREQ,
                                gpio_pin_pwm_mono);
  audio_target.init(3);
#else
  const uint8_t gpio_pin_i2s_clock_base =
    PICO_AUDIO_I2S_CLOCK_PIN_BASE; // GPIO 10 (BLCK) + GPIO 11 (LRCLK)
  const uint8_t gpio_pin_i2s_data =
    PICO_AUDIO_I2S_DATA_PIN; // GPIO 9 (DATA)
  I2S_audio_target audio_target(Simple_stupid_synth::DEFAULT_SAMPLE_FREQ,
                                gpio_pin_i2s_clock_base, gpio_pin_i2s_data);
  audio_target.init();
#endif

  init_display();
  init_leds();
  for (int i = 0; i < 4; i++)
  {
    set_led(  i, 0x04 + i*0x10, 0, 0);
    set_led(7-i, 0x04 + i*0x10, 0, 0);
  }
  update_leds();
  display_wifi();
  init_adc();

  MIDI_state_machine midi_state_machine;
  Network_source network_source(&midi_state_machine);
  NTP_client ntp;
  network_source.set_ntp(&ntp);

  if (network_source.has_wifi)
  {
    display_waiting();
    for (int i = 0; i < 4; i++)
    {
      set_led(  i, 0, 0x04 + i*0x10, 0);
      set_led(7-i, 0, 0x04 + i*0x10, 0);
    }
  }else{
    for (int i = 0; i < 4; i++)
    {
      set_led(  i, 0x70 - i*0x20, 0, 0);
      set_led(7-i, 0x70 - i*0x20, 0, 0);
    }
  }
  update_leds();

  const uint8_t gpio_pin_activity_indicator =
    Simple_stupid_synth::GPIO_PIN_LED;
  Simple_stupid_synth simple_stupid_synth(&audio_target,
                                          &midi_state_machine,
                                          &network_source,
                                          &ntp,
                                          gpio_pin_activity_indicator);
  simple_stupid_synth.main_loop();
  return 0;
}
